# -*- coding: utf-8 -*-
"""main_1 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1epsfGRNa5O63a7EvRCFgu7X0JGsig4a6
"""

import numpy as np
import pandas as pd
from sklearn.metrics import accuracy_score, f1_score
import time

dftrain = pd.read_csv('/content/MNIST_train.csv')
dfval = pd.read_csv('/content/MNIST_validation.csv')

dftrain = dftrain.drop('even', axis=1)

dfval = dfval.drop('even', axis=1)

featurecols = list(dftrain.columns)
targetcol = 'label'
featurecols.remove(targetcol)

print('length of featurecolumns is', len(featurecols))

Xtrain = np.array(dftrain[featurecols]) / 255
ytrain = np.array(dftrain[targetcol])

Xval = np.array(dfval[featurecols]) / 255
yval = np.array(dfval[targetcol])

class PCAModel:
    def __init__(self, n_components):
        self.n_components = n_components
        self.mean = None
        self.components = None
        self.explained_variance = None

    def fit(self, X):
        X = np.array(X, dtype=float)

        self.mean = np.mean(X, axis=0)
        X_centered = X - self.mean

        cov_matrix = np.cov(X_centered, rowvar=False)
        eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)

        sorted_idx = np.argsort(eigenvalues)[::-1]

        self.explained_variance = eigenvalues[sorted_idx][:self.n_components]
        self.components = eigenvectors[:, sorted_idx][:, :self.n_components]

    def predict(self, X):
        if self.mean is None:
            raise ValueError("PCA is not fitted yet.")

        X_centered = X - self.mean
        return np.dot(X_centered, self.components)

    def reconstruct(self, X):
        Z = self.predict(X)
        return np.dot(Z, self.components.T) + self.mean

class KNNClassifier:
    def __init__(self, k=5):
        self.k = k
        self.X_train = None
        self.y_train = None

    def fit(self, X, y):
        self.X_train = np.array(X)
        self.y_train = np.array(y)

    def predict(self, X):
        X = np.array(X)
        y_pred = []
        for x in X:
            distances = np.linalg.norm(self.X_train - x, axis=1)
            nn_idx = np.argsort(distances)[:self.k]
            nn_labels = self.y_train[nn_idx]
            counts = np.bincount(nn_labels)
            y_pred.append(np.argmax(counts))
        return np.array(y_pred)

pca = PCAModel(n_components=100)
pca.fit(Xtrain)
X_train_pca = pca.predict(Xtrain)
X_val_pca = pca.predict(Xval)

print(f"Shape after PCA: {X_train_pca.shape}")
knn = KNNClassifier(k=5)
start_time = time.time()
knn.fit(X_train_pca, ytrain)
y_train_pred = knn.predict(X_train_pca)
y_val_pred = knn.predict(X_val_pca)
training_time = time.time() - start_time
train_acc = accuracy_score(ytrain, y_train_pred)
val_acc = accuracy_score(yval, y_val_pred)
train_f1 = f1_score(ytrain, y_train_pred, average='weighted')
val_f1 = f1_score(yval, y_val_pred, average='weighted')

print("----------------------------")
print("KNN + PCA ")
print("----------------------------")
print(f"Train Accuracy: {train_acc:.4f}")
print(f"Validation Accuracy: {val_acc:.4f}")
print(f"Train F1: {train_f1:.4f}")
print(f"Validation F1: {val_f1:.4f}")
print(f"Training + Prediction time: {training_time:.2f} seconds")